;;; Quickstart file to activate all packages at startup  -*- lexical-binding:t -*-
;; ¡¡ This file is autogenerated by `package-quickstart-refresh', DO NOT EDIT !!

(let ((load-file-name "/home/das/.emacs.d/elpa/xwidgets-reuse-20200817.147/xwidgets-reuse-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/xwidgets-reuse-20200817.147/xwidgets-reuse-autoloads.el") (car load-path))))



(autoload 'xwidgets-reuse-register-minor-mode "xwidgets-reuse" "\
Registers a MINOR-MODE with xwidgets-reuse.
This minor mode will automatically be turned off when another minor mode from
`xwidgets-reuse--xwidgets-specialization-minor-modes' is used through
`xwidgets-reuse-xwidget-reuse-browse-url'.

\(fn MINOR-MODE)" nil nil)

(autoload 'xwidgets-reuse-xwidget-reuse-browse-url "xwidgets-reuse" "\
Open URL using xwidgets, reusing an existing xwidget buffer if possible.
Optional argument USE-MINOR-MODE is a minor mode to be activated
in the xwidgets session (e.g., for custom keybindings).

\(fn URL &optional USE-MINOR-MODE)" t nil)

(autoload 'xwidgets-reuse-xwidget-external-browse-current-url "xwidgets-reuse" "\
Externally browse url shown in current xwidget session.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "xwidgets-reuse" '("xwidgets-reuse-")))


)
(let ((load-file-name "/home/das/.emacs.d/elpa/whole-line-or-region-20201214.650/whole-line-or-region-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/whole-line-or-region-20201214.650/whole-line-or-region-autoloads.el") (car load-path))))



(autoload 'whole-line-or-region-local-mode "whole-line-or-region" "\
Make chosen commands operate on the current line if no region is active.
Modify `whole-line-or-region-local-mode-map' to change which
commands are affected.

\(fn &optional ARG)" t nil)

(defvar whole-line-or-region-global-mode nil "\
Non-nil if Whole-Line-Or-Region-Global mode is enabled.
See the `whole-line-or-region-global-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `whole-line-or-region-global-mode'.")

(custom-autoload 'whole-line-or-region-global-mode "whole-line-or-region" nil)

(autoload 'whole-line-or-region-global-mode "whole-line-or-region" "\
Toggle Whole-Line-Or-Region-Local mode in all buffers.
With prefix ARG, enable Whole-Line-Or-Region-Global mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Whole-Line-Or-Region-Local mode is enabled in all buffers where
`(lambda nil (unless (apply (quote derived-mode-p) whole-line-or-region-inhibit-modes) (whole-line-or-region-local-mode 1)))' would do it.
See `whole-line-or-region-local-mode' for more information on Whole-Line-Or-Region-Local mode.

\(fn &optional ARG)" t nil)

(autoload 'whole-line-or-region-copy-region-as-kill "whole-line-or-region" "\
Call `copy-region-as-kill' on region or PREFIX whole lines.

\(fn PREFIX)" t nil)

(autoload 'whole-line-or-region-kill-region "whole-line-or-region" "\
Call `kill-region' on region or PREFIX whole lines.

\(fn PREFIX)" t nil)

(autoload 'whole-line-or-region-kill-ring-save "whole-line-or-region" "\
Call `kill-ring-save' on region or PREFIX whole lines.

\(fn PREFIX)" t nil)

(autoload 'whole-line-or-region-delete-region "whole-line-or-region" "\
Call `delete-region' on region or PREFIX whole lines.

\(fn PREFIX)" t nil)

(autoload 'whole-line-or-region-comment-region "whole-line-or-region" "\
Call `comment-region' on region or PREFIX whole lines.

\(fn PREFIX)" t nil)

(autoload 'whole-line-or-region-comment-dwim "whole-line-or-region" "\
Call `comment-dwim' on region or current line.
PREFIX is passed unchanged to `comment-dwim'.

\(fn PREFIX)" t nil)

(autoload 'whole-line-or-region-comment-dwim-2 "whole-line-or-region" "\
Call `comment-dwim' on region or PREFIX whole line.

\(fn PREFIX)" t nil)

(autoload 'whole-line-or-region-uncomment-region "whole-line-or-region" "\
Call `uncomment-region' on region or PREFIX whole lines.

\(fn PREFIX)" t nil)

(autoload 'whole-line-or-region-comment-or-uncomment-region "whole-line-or-region" "\
Call `comment-or-uncomment-region' on region or PREFIX whole lines.

\(fn PREFIX)" t nil)

(autoload 'whole-line-or-region-indent-rigidly-left-to-tab-stop "whole-line-or-region" "\
Call `indent-rigidly-left-to-tab-stop' on region or PREFIX whole lines.

\(fn PREFIX)" t nil)

(autoload 'whole-line-or-region-indent-rigidly-right-to-tab-stop "whole-line-or-region" "\
Call `indent-rigidly-right-to-tab-stop' on region or PREFIX whole lines.

\(fn PREFIX)" t nil)

(autoload 'whole-line-or-region-indent-rigidly-left "whole-line-or-region" "\
Call `indent-rigidly-left-to-tab-stop' on region or PREFIX whole lines.

\(fn PREFIX)" t nil)

(autoload 'whole-line-or-region-indent-rigidly-right "whole-line-or-region" "\
Call `indent-rigidly-right-to-tab-stop' on region or PREFIX whole lines.

\(fn PREFIX)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "whole-line-or-region" '("whole-line-or-region-")))


)
(let ((load-file-name "/home/das/.emacs.d/elpa/bind-key-20210210.1609/bind-key-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/bind-key-20210210.1609/bind-key-autoloads.el") (car load-path))))



(autoload 'bind-key "bind-key" "\
Bind KEY-NAME to COMMAND in KEYMAP (`global-map' if not passed).

KEY-NAME may be a vector, in which case it is passed straight to
`define-key'. Or it may be a string to be interpreted as
spelled-out keystrokes, e.g., \"C-c C-z\". See documentation of
`edmacro-mode' for details.

COMMAND must be an interactive function or lambda form.

KEYMAP, if present, should be a keymap variable or symbol.
For example:

  (bind-key \"M-h\" #'some-interactive-function my-mode-map)

  (bind-key \"M-h\" #'some-interactive-function 'my-mode-map)

If PREDICATE is non-nil, it is a form evaluated to determine when
a key should be bound. It must return non-nil in such cases.
Emacs can evaluate this form at any time that it does redisplay
or operates on menu data structures, so you should write it so it
can safely be called at any time.

\(fn KEY-NAME COMMAND &optional KEYMAP PREDICATE)" nil t)

(autoload 'unbind-key "bind-key" "\
Unbind the given KEY-NAME, within the KEYMAP (if specified).
See `bind-key' for more details.

\(fn KEY-NAME &optional KEYMAP)" nil t)

(autoload 'bind-key* "bind-key" "\
Similar to `bind-key', but overrides any mode-specific bindings.

\(fn KEY-NAME COMMAND &optional PREDICATE)" nil t)

(autoload 'bind-keys "bind-key" "\
Bind multiple keys at once.

Accepts keyword arguments:
:map MAP               - a keymap into which the keybindings should be
                         added
:prefix KEY            - prefix key for these bindings
:prefix-map MAP        - name of the prefix map that should be created
                         for these bindings
:prefix-docstring STR  - docstring for the prefix-map variable
:menu-name NAME        - optional menu string for prefix map
:filter FORM           - optional form to determine when bindings apply

The rest of the arguments are conses of keybinding string and a
function symbol (unquoted).

\(fn &rest ARGS)" nil t)

(autoload 'bind-keys* "bind-key" "\


\(fn &rest ARGS)" nil t)

(autoload 'describe-personal-keybindings "bind-key" "\
Display all the personal keybindings defined by `bind-key'." t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "bind-key" '("bind-key" "compare-keybindings" "get-binding-description" "override-global-m" "personal-keybindings")))


)
(let ((load-file-name "/home/das/.emacs.d/elpa/use-package-20210207.1926/use-package-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/use-package-20210207.1926/use-package-autoloads.el") (car load-path))))



(autoload 'use-package-autoload-keymap "use-package-bind-key" "\
Loads PACKAGE and then binds the key sequence used to invoke
this function to KEYMAP-SYMBOL. It then simulates pressing the
same key sequence a again, so that the next key pressed is routed
to the newly loaded keymap.

This function supports use-package's :bind-keymap keyword. It
works by binding the given key sequence to an invocation of this
function for a particular keymap. The keymap is expected to be
defined by the package. In this way, loading the package is
deferred until the prefix key sequence is pressed.

\(fn KEYMAP-SYMBOL PACKAGE OVERRIDE)" nil nil)

(autoload 'use-package-normalize-binder "use-package-bind-key" "\


\(fn NAME KEYWORD ARGS)" nil nil)

(defalias 'use-package-normalize/:bind 'use-package-normalize-binder)

(defalias 'use-package-normalize/:bind* 'use-package-normalize-binder)

(defalias 'use-package-autoloads/:bind 'use-package-autoloads-mode)

(defalias 'use-package-autoloads/:bind* 'use-package-autoloads-mode)

(autoload 'use-package-handler/:bind "use-package-bind-key" "\


\(fn NAME KEYWORD ARGS REST STATE &optional BIND-MACRO)" nil nil)

(defalias 'use-package-normalize/:bind-keymap 'use-package-normalize-binder)

(defalias 'use-package-normalize/:bind-keymap* 'use-package-normalize-binder)

(autoload 'use-package-handler/:bind-keymap "use-package-bind-key" "\


\(fn NAME KEYWORD ARGS REST STATE &optional OVERRIDE)" nil nil)

(autoload 'use-package-handler/:bind-keymap* "use-package-bind-key" "\


\(fn NAME KEYWORD ARG REST STATE)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "use-package-bind-key" '("use-package-handler/:bind*")))



(autoload 'use-package "use-package-core" "\
Declare an Emacs package by specifying a group of configuration options.

For full documentation, please see the README file that came with
this file.  Usage:

  (use-package package-name
     [:keyword [option]]...)

:init            Code to run before PACKAGE-NAME has been loaded.
:config          Code to run after PACKAGE-NAME has been loaded.  Note that
                 if loading is deferred for any reason, this code does not
                 execute until the lazy load has occurred.
:preface         Code to be run before everything except `:disabled'; this
                 can be used to define functions for use in `:if', or that
                 should be seen by the byte-compiler.

:mode            Form to be added to `auto-mode-alist'.
:magic           Form to be added to `magic-mode-alist'.
:magic-fallback  Form to be added to `magic-fallback-mode-alist'.
:interpreter     Form to be added to `interpreter-mode-alist'.

:commands        Define autoloads for commands that will be defined by the
                 package.  This is useful if the package is being lazily
                 loaded, and you wish to conditionally call functions in your
                 `:init' block that are defined in the package.
:hook            Specify hook(s) to attach this package to.

:bind            Bind keys, and define autoloads for the bound commands.
:bind*           Bind keys, and define autoloads for the bound commands,
                 *overriding all minor mode bindings*.
:bind-keymap     Bind a key prefix to an auto-loaded keymap defined in the
                 package.  This is like `:bind', but for keymaps.
:bind-keymap*    Like `:bind-keymap', but overrides all minor mode bindings

:defer           Defer loading of a package -- this is implied when using
                 `:commands', `:bind', `:bind*', `:mode', `:magic', `:hook',
                 `:magic-fallback', or `:interpreter'.  This can be an integer,
                 to force loading after N seconds of idle time, if the package
                 has not already been loaded.
:after           Delay the use-package declaration until after the named modules
                 have loaded. Once load, it will be as though the use-package
                 declaration (without `:after') had been seen at that moment.
:demand          Prevent the automatic deferred loading introduced by constructs
                 such as `:bind' (see `:defer' for the complete list).

:if EXPR         Initialize and load only if EXPR evaluates to a non-nil value.
:disabled        The package is ignored completely if this keyword is present.
:defines         Declare certain variables to silence the byte-compiler.
:functions       Declare certain functions to silence the byte-compiler.
:load-path       Add to the `load-path' before attempting to load the package.
:diminish        Support for diminish.el (if installed).
:delight         Support for delight.el (if installed).
:custom          Call `custom-set' or `set-default' with each variable
                 definition without modifying the Emacs `custom-file'.
                 (compare with `custom-set-variables').
:custom-face     Call `customize-set-faces' with each face definition.
:ensure          Loads the package using package.el if necessary.
:pin             Pin the package to an archive.

\(fn NAME &rest ARGS)" nil t)

(function-put 'use-package 'lisp-indent-function '1)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "use-package-core" '("use-package-")))



(autoload 'use-package-normalize/:delight "use-package-delight" "\
Normalize arguments to delight.

\(fn NAME KEYWORD ARGS)" nil nil)

(autoload 'use-package-handler/:delight "use-package-delight" "\


\(fn NAME KEYWORD ARGS REST STATE)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "use-package-delight" '("use-package-normalize-delight")))



(autoload 'use-package-normalize/:diminish "use-package-diminish" "\


\(fn NAME KEYWORD ARGS)" nil nil)

(autoload 'use-package-handler/:diminish "use-package-diminish" "\


\(fn NAME KEYWORD ARG REST STATE)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "use-package-diminish" '("use-package-normalize-diminish")))



(autoload 'use-package-normalize/:ensure "use-package-ensure" "\


\(fn NAME KEYWORD ARGS)" nil nil)

(autoload 'use-package-handler/:ensure "use-package-ensure" "\


\(fn NAME KEYWORD ENSURE REST STATE)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "use-package-ensure" '("use-package-")))



(autoload 'use-package-jump-to-package-form "use-package-jump" "\
Attempt to find and jump to the `use-package' form that loaded
PACKAGE. This will only find the form if that form actually
required PACKAGE. If PACKAGE was previously required then this
function will jump to the file that originally required PACKAGE
instead.

\(fn PACKAGE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "use-package-jump" '("use-package-find-require")))



(autoload 'use-package-lint "use-package-lint" "\
Check for errors in use-package declarations.
For example, if the module's `:if' condition is met, but even
with the specified `:load-path' the module cannot be found." t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "use-package-lint" '("use-package-lint-declaration")))




)
(let ((load-file-name "/home/das/.emacs.d/elpa/macrostep-20161120.2106/macrostep-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/macrostep-20161120.2106/macrostep-autoloads.el") (car load-path))))



(autoload 'macrostep-mode "macrostep" "\
Minor mode for inline expansion of macros in Emacs Lisp source buffers.

\\<macrostep-keymap>Progressively expand macro forms with \\[macrostep-expand], collapse them with \\[macrostep-collapse],
and move back and forth with \\[macrostep-next-macro] and \\[macrostep-prev-macro].
Use \\[macrostep-collapse-all] or collapse all visible expansions to
quit and return to normal editing.

\\{macrostep-keymap}

\(fn &optional ARG)" t nil)

(autoload 'macrostep-expand "macrostep" "\
Expand the macro form following point by one step.

Enters `macrostep-mode' if it is not already active, making the
buffer temporarily read-only. If macrostep-mode is active and the
form following point is not a macro form, search forward in the
buffer and expand the next macro form found, if any.

With a prefix argument, the expansion is displayed in a separate
buffer instead of inline in the current buffer.  Setting
`macrostep-expand-in-separate-buffer' to non-nil swaps these two
behaviors.

\(fn &optional TOGGLE-SEPARATE-BUFFER)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "macrostep" '("macrostep-")))



(autoload 'macrostep-c-mode-hook "macrostep-c" "\


\(fn)" nil nil)

(add-hook 'c-mode-hook #'macrostep-c-mode-hook)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "macrostep-c" '("macrostep-c-")))




)
(let ((load-file-name "/home/das/.emacs.d/elpa/slime-20210417.1210/slime-autoloads.el"))






(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/slime-20210417.1210/slime-autoloads.el") (car load-path))))

(autoload 'slime "slime"
  "Start a Lisp subprocess and connect to its Swank server." t)

(autoload 'slime-mode "slime"
  "SLIME: The Superior Lisp Interaction (Minor) Mode for Emacs." t)

(autoload 'slime-connect "slime"
  "Connect to a running Swank server." t)

(autoload 'slime-selector "slime"
  "Select a new by type, indicated by a single character." t)

(autoload 'hyperspec-lookup "lib/hyperspec" nil t)

(autoload 'slime-lisp-mode-hook "slime")

(autoload 'slime-scheme-mode-hook "slime")

(defvar slime-contribs '(slime-fancy)
  "A list of contrib packages to load with SLIME.")

(autoload 'slime-setup "slime"
  "Setup some SLIME contribs.")

(define-obsolete-variable-alias 'slime-setup-contribs
  'slime-contribs "2.3.2")

(add-hook 'lisp-mode-hook 'slime-lisp-mode-hook)

(provide 'slime-autoloads)



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "slime" '("??" "?c" "?d" "?e" "?i" "?l" "?n" "?p" "?q" "?t" "?v" "def-slime-selector-method" "define-sl" "defslimefun" "inferior-lisp-program" "make-slime-" "sldb-" "slime")))





(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "slime-tests" '("arglist" "async-eval-debugging" "break" "comp" "def-slime-test" "dis" "end-of-file" "find-definition" "flow-control" "indentation" "inspector" "inter" "locally-bound-debugger-hook" "loop-interrupt-" "macroexpand" "narrowing" "read" "report-condition-with-circular-list" "sbcl-world-lock" "sexp-at-point.1" "symbol-at-point." "traditional-recipe" "unwind-to-previous-sldb-level" "utf-8-source")))

)
(let ((load-file-name "/home/das/.emacs.d/elpa/shrink-whitespace-20181003.321/shrink-whitespace-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/shrink-whitespace-20181003.321/shrink-whitespace-autoloads.el") (car load-path))))



(autoload 'shrink-whitespace "shrink-whitespace" "\
Remove whitespace around cursor to just one or none.
If current line contains non-white space chars, then shrink any
whitespace char surrounding cursor to just one space.  If current
line does not contain non-white space chars, then remove blank
lines to just one.
Argument ARG Prevents removal of newlines when no other whitespace exists.

\(fn ARG)" t nil)

(autoload 'shrink-whitespace-grow-whitespace-around "shrink-whitespace" "\
Counterpart to 'shrink-whitespace', grow whitespace in a smartish way." t nil)

(autoload 'shrink-whitespace-shrink-whitespace-around "shrink-whitespace" "\
Shrink whitespace surrounding point." t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "shrink-whitespace" '("grow-whitespace-around" "shrink-whitespace-")))


)
(let ((load-file-name "/home/das/.emacs.d/elpa/request-20210410.2218/request-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/request-20210410.2218/request-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "request" '("request-")))


)
(let ((load-file-name "/home/das/.emacs.d/elpa/recently-20200120.1432/recently-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/recently-20200120.1432/recently-autoloads.el") (car load-path))))



(defvar recently-mode nil "\
Non-nil if Recently mode is enabled.
See the `recently-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `recently-mode'.")

(custom-autoload 'recently-mode "recently" nil)

(autoload 'recently-mode "recently" "\
Track recently opened files.
When enabled it records recently opened file paths, and
view list and visit again via `recently-show' command.

\(fn &optional ARG)" t nil)

(autoload 'recently-show "recently" "\
Show buffet that lists recently opened files.
BUFFER-NAME, if given, should be a string for buffer to create.

\(fn &optional BUFFER-NAME)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "recently" '("recently-")))


)
(let ((load-file-name "/home/das/.emacs.d/elpa/packed-20201120.2047/packed-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/packed-20201120.2047/packed-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "packed" '("packed-")))


)
(let ((load-file-name "/home/das/.emacs.d/elpa/org-20201216/org-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/org-20201216/org-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-C" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-J" '("obj-" "org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-R" '("ob-R-" "org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-abc" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-asymptote" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-awk" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-calc" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-clojure" '("ob-clojure-" "org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-comint" '("org-babel-comint-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-coq" '("coq-program-name" "org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-css" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-ditaa" '("org-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-dot" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-ebnf" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-emacs-lisp" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-eshell" '("ob-eshell-session-live-p" "org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-eval" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-exp" '("org-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-forth" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-fortran" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-gnuplot" '("*org-babel-gnuplot-" "org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-groovy" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-haskell" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-hledger" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-io" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-java" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-js" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-latex" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-ledger" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-lilypond" '("lilypond-mode" "org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-lisp" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-lua" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-makefile" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-maxima" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-mscgen" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-ocaml" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-octave" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-org" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-perl" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-picolisp" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-plantuml" '("org-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-processing" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-python" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-ref" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-ruby" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-sass" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-scheme" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-screen" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-sed" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-shell" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-shen" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-sql" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-sqlite" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-stan" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-table" '("org-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ob-vala" '("org-babel-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ol" '("org-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ol-bibtex" '("org-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ol-docview" '("org-docview-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ol-eshell" '("org-eshell-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ol-eww" '("org-eww-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ol-gnus" '("org-gnus-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ol-info" '("org-info-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ol-mhe" '("org-mhe-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ol-rmail" '("org-rmail-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ol-w3m" '("org-w3m-")))



(autoload 'org-babel-do-load-languages "org" "\
Load the languages defined in `org-babel-load-languages'.

\(fn SYM VALUE)" nil nil)

(autoload 'org-babel-load-file "org" "\
Load Emacs Lisp source code blocks in the Org FILE.
This function exports the source code using `org-babel-tangle'
and then loads the resulting file using `load-file'.  With
optional prefix argument COMPILE, the tangled Emacs Lisp file is
byte-compiled before it is loaded.

\(fn FILE &optional COMPILE)" t nil)

(autoload 'org-version "org" "\
Show the Org version.
Interactively, or when MESSAGE is non-nil, show it in echo area.
With prefix argument, or when HERE is non-nil, insert it at point.
In non-interactive uses, a reduced version string is output unless
FULL is given.

\(fn &optional HERE FULL MESSAGE)" t nil)

(autoload 'org-load-modules-maybe "org" "\
Load all extensions listed in `org-modules'.

\(fn &optional FORCE)" nil nil)

(autoload 'org-clock-persistence-insinuate "org" "\
Set up hooks for clock persistence." nil nil)

(autoload 'org-mode "org" "\
Outline-based notes management and organizer, alias
\"Carsten's outline-mode for keeping track of everything.\"

Org mode develops organizational tasks around a NOTES file which
contains information about projects as plain text.  Org mode is
implemented on top of Outline mode, which is ideal to keep the content
of large files well structured.  It supports ToDo items, deadlines and
time stamps, which magically appear in the diary listing of the Emacs
calendar.  Tables are easily created with a built-in table editor.
Plain text URL-like links connect to websites, emails (VM), Usenet
messages (Gnus), BBDB entries, and any files related to the project.
For printing and sharing of notes, an Org file (or a part of it)
can be exported as a structured ASCII or HTML file.

The following commands are available:

\\{org-mode-map}

\(fn)" t nil)

(autoload 'org-cycle "org" "\
TAB-action and visibility cycling for Org mode.

This is the command invoked in Org mode by the `TAB' key.  Its main
purpose is outline visibility cycling, but it also invokes other actions
in special contexts.

When this function is called with a `\\[universal-argument]' prefix, rotate the entire
buffer through 3 states (global cycling)
  1. OVERVIEW: Show only top-level headlines.
  2. CONTENTS: Show all headlines of all levels, but no body text.
  3. SHOW ALL: Show everything.

With a `\\[universal-argument] \\[universal-argument]' prefix argument, switch to the startup visibility,
determined by the variable `org-startup-folded', and by any VISIBILITY
properties in the buffer.

With a `\\[universal-argument] \\[universal-argument] \\[universal-argument]' prefix argument, show the entire buffer, including
any drawers.

When inside a table, re-align the table and move to the next field.

When point is at the beginning of a headline, rotate the subtree started
by this line through 3 different states (local cycling)
  1. FOLDED:   Only the main headline is shown.
  2. CHILDREN: The main headline and the direct children are shown.
               From this state, you can move to one of the children
               and zoom in further.
  3. SUBTREE:  Show the entire subtree, including body text.
If there is no subtree, switch directly from CHILDREN to FOLDED.

When point is at the beginning of an empty headline and the variable
`org-cycle-level-after-item/entry-creation' is set, cycle the level
of the headline by demoting and promoting it to likely levels.  This
speeds up creation document structure by pressing `TAB' once or several
times right after creating a new headline.

When there is a numeric prefix, go up to a heading with level ARG, do
a `show-subtree' and return to the previous cursor position.  If ARG
is negative, go up that many levels.

When point is not at the beginning of a headline, execute the global
binding for `TAB', which is re-indenting the line.  See the option
`org-cycle-emulate-tab' for details.

As a special case, if point is at the very beginning of the buffer, if
there is no headline there, and if the variable `org-cycle-global-at-bob'
is non-nil, this function acts as if called with prefix argument (`\\[universal-argument] TAB',
same as `S-TAB') also when called without prefix argument.

\(fn &optional ARG)" t nil)

(autoload 'org-global-cycle "org" "\
Cycle the global visibility.  For details see `org-cycle'.
With `\\[universal-argument]' prefix ARG, switch to startup visibility.
With a numeric prefix, show all headlines up to that level.

\(fn &optional ARG)" t nil)

(autoload 'org-run-like-in-org-mode "org" "\
Run a command, pretending that the current buffer is in Org mode.
This will temporarily bind local variables that are typically bound in
Org mode to the values they have in Org mode, and then interactively
call CMD.

\(fn CMD)" nil nil)

(autoload 'org-open-file "org" "\
Open the file at PATH.
First, this expands any special file name abbreviations.  Then the
configuration variable `org-file-apps' is checked if it contains an
entry for this file type, and if yes, the corresponding command is launched.

If no application is found, Emacs simply visits the file.

With optional prefix argument IN-EMACS, Emacs will visit the file.
With a double \\[universal-argument] \\[universal-argument] prefix arg, Org tries to avoid opening in Emacs
and to use an external application to visit the file.

Optional LINE specifies a line to go to, optional SEARCH a string
to search for.  If LINE or SEARCH is given, the file will be
opened in Emacs, unless an entry from `org-file-apps' that makes
use of groups in a regexp matches.

If you want to change the way frames are used when following a
link, please customize `org-link-frame-setup'.

If the file does not exist, throw an error.

\(fn PATH &optional IN-EMACS LINE SEARCH)" nil nil)

(autoload 'org-open-at-point-global "org" "\
Follow a link or a time-stamp like Org mode does.
Also follow links and emails as seen by `thing-at-point'.
This command can be called in any mode to follow an external
link or a time-stamp that has Org mode syntax.  Its behavior
is undefined when called on internal links like fuzzy links.
Raise a user error when there is nothing to follow." t nil)

(autoload 'org-offer-links-in-entry "org" "\
Offer links in the current entry and return the selected link.
If there is only one link, return it.
If NTH is an integer, return the NTH link found.
If ZERO is a string, check also this string for a link, and if
there is one, return it.

\(fn BUFFER MARKER &optional NTH ZERO)" nil nil)

(autoload 'org-switchb "org" "\
Switch between Org buffers.

With `\\[universal-argument]' prefix, restrict available buffers to files.

With `\\[universal-argument] \\[universal-argument]' prefix, restrict available buffers to agenda files.

\(fn &optional ARG)" t nil)

(autoload 'org-cycle-agenda-files "org" "\
Cycle through the files in `org-agenda-files'.
If the current buffer visits an agenda file, find the next one in the list.
If the current buffer does not, find the first agenda file." t nil)

(autoload 'org-submit-bug-report "org" "\
Submit a bug report on Org via mail.

Don't hesitate to report any problems or inaccurate documentation.

If you don't have setup sending mail from (X)Emacs, please copy the
output buffer into your mail program, as it gives us important
information about your Org version and configuration." t nil)

(autoload 'org-reload "org" "\
Reload all Org Lisp files.
With prefix arg UNCOMPILED, load the uncompiled versions.

\(fn &optional UNCOMPILED)" t nil)

(autoload 'org-customize "org" "\
Call the customize function with org as argument." t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "org" '("org-" "turn-on-org-cdlatex")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "org-attach" '("org-attach-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "org-attach-git" '("org-attach-git-")))



(autoload 'org-encrypt-entry "org-crypt" "\
Encrypt the content of the current headline." t nil)

(autoload 'org-decrypt-entry "org-crypt" "\
Decrypt the content of the current headline." t nil)

(autoload 'org-encrypt-entries "org-crypt" "\
Encrypt all top-level entries in the current buffer." t nil)

(autoload 'org-decrypt-entries "org-crypt" "\
Decrypt all entries in the current buffer." t nil)

(autoload 'org-crypt-use-before-save-magic "org-crypt" "\
Add a hook to automatically encrypt entries before a file is saved to disk." nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "org-crypt" '("org-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "org-ctags" '("org-ctags-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "org-entities" '("org-entit")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "org-faces" '("org-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "org-habit" '("org-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "org-inlinetask" '("org-inlinetask-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "org-macro" '("org-macro-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "org-mouse" '("org-mouse-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "org-pcomplete" '("org-" "pcomplete/org-mode/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "org-protocol" '("org-protocol-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "org-refile" '("org-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "org-src" '("org-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "org-table" '("org")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "org-tempo" '("org-tempo-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "org-timer" '("org-timer-")))



(autoload 'org-release "org-version" "\
The release version of Org.
Inserted by installing Org mode or when a release is made." nil nil)

(autoload 'org-git-version "org-version" "\
The Git version of Org mode.
Inserted by installing Org or when a release is made." nil nil)



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ox" '("org-export-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ox-ascii" '("org-ascii-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ox-beamer" '("org-beamer-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ox-html" '("org-html-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ox-icalendar" '("org-icalendar-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ox-latex" '("org-latex-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ox-man" '("org-man-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ox-md" '("org-md-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ox-odt" '("org-odt-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ox-org" '("org-org-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ox-publish" '("org-publish-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ox-texinfo" '("org-texinfo-")))




)
(let ((load-file-name "/home/das/.emacs.d/elpa/ox-hugo-20210330.1758/ox-hugo-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/ox-hugo-20210330.1758/ox-hugo-autoloads.el") (car load-path))))



(autoload 'org-hugo-auto-export-mode "org-hugo-auto-export-mode" "\
Toggle auto exporting the Org file using `ox-hugo'.

If called interactively, enable Org-Hugo-Auto-Export mode if ARG
is positive, and disable it if ARG is zero or negative.  If
called from Lisp, also enable the mode if ARG is omitted or nil,
and toggle it if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "org-hugo-auto-export-mode" '("org-hugo-export-wim-to-md-after-save")))



(autoload 'org-blackfriday-export-as-markdown "ox-blackfriday" "\
Export current buffer to a Github Flavored Markdown buffer.

If narrowing is active in the current buffer, only export its
narrowed part.

If a region is active, export that region.

A non-nil optional argument ASYNC means the process should happen
asynchronously.  The resulting buffer should be accessible
through the `org-export-stack' interface.

When optional argument SUBTREEP is non-nil, export the sub-tree
at point, extracting information from the headline properties
first.

When optional argument VISIBLE-ONLY is non-nil, don't export
contents of hidden elements.

Export is done in a buffer named \"*Org BLACKFRIDAY Export*\", which will
be displayed when `org-export-show-temporary-export-buffer' is
non-nil.

\(fn &optional ASYNC SUBTREEP VISIBLE-ONLY)" t nil)

(autoload 'org-blackfriday-convert-region-to-md "ox-blackfriday" "\
Convert text in the current region to Blackfriday Markdown.
The text is assumed to be in Org mode format.

This can be used in any buffer.  For example, you can write an
itemized list in Org mode syntax in a Markdown buffer and use
this command to convert it." t nil)

(autoload 'org-blackfriday-export-to-markdown "ox-blackfriday" "\
Export current buffer to a Github Flavored Markdown file.

If narrowing is active in the current buffer, only export its
narrowed part.

If a region is active, export that region.

A non-nil optional argument ASYNC means the process should happen
asynchronously.  The resulting file should be accessible through
the `org-export-stack' interface.

When optional argument SUBTREEP is non-nil, export the sub-tree
at point, extracting information from the headline properties
first.

When optional argument VISIBLE-ONLY is non-nil, don't export
contents of hidden elements.

Return output file's name.

\(fn &optional ASYNC SUBTREEP VISIBLE-ONLY)" t nil)

(autoload 'org-blackfriday-publish-to-blackfriday "ox-blackfriday" "\
Publish an Org file to Blackfriday Markdown file.

PLIST is the property list for the given project.  FILENAME is
the filename of the Org file to be published.  PUB-DIR is the
publishing directory.

Return output file name.

\(fn PLIST FILENAME PUB-DIR)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ox-blackfriday" '("org-blackfriday-")))


 (put 'org-hugo-section 'safe-local-variable 'stringp)
 (put 'org-hugo-front-matter-format 'safe-local-variable 'stringp)
 (put 'org-hugo-footer 'safe-local-variable 'stringp)
 (put 'org-hugo-preserve-filling 'safe-local-variable 'booleanp)
 (put 'org-hugo-delete-trailing-ws 'safe-local-variable 'booleanp)
 (put 'org-hugo-use-code-for-kbd 'safe-local-variable 'booleanp)
 (put 'org-hugo-allow-spaces-in-tags 'safe-local-variable 'booleanp)
 (put 'org-hugo-prefer-hyphen-in-tags 'safe-local-variable 'booleanp)
 (put 'org-hugo-auto-set-lastmod 'safe-local-variable 'booleanp)
 (put 'org-hugo-suppress-lastmod-period 'safe-local-variable 'floatp)
 (put 'org-hugo-export-with-toc 'safe-local-variable (lambda (x) (or (booleanp x) (integerp x))))
 (put 'org-hugo-export-with-section-numbers 'safe-local-variable (lambda (x) (or (booleanp x) (equal 'onlytoc x) (integerp x))))
 (put 'org-hugo-default-static-subdirectory-for-externals 'safe-local-variable 'stringp)
 (put 'org-hugo-export-creator-string 'safe-local-variable 'stringp)
 (put 'org-hugo-date-format 'safe-local-variable 'stringp)
 (put 'org-hugo-paired-shortcodes 'safe-local-variable 'stringp)
 (put 'org-hugo-link-desc-insert-type 'safe-local-variable 'booleanp)

(autoload 'org-hugo-slug "ox-hugo" "\
Convert string STR to a `slug' and return that string.

A `slug' is the part of a URL which identifies a particular page
on a website in an easy to read form.

Example: If STR is \"My First Post\", it will be converted to a
slug \"my-first-post\", which can become part of an easy to read
URL like \"https://example.com/posts/my-first-post/\".

In general, STR is a string.  But it can also be a string with
Markdown markup as that string passed to this function is often
the sub-headings of a post (which can contain bold, italics,
link, etc markup).

The `slug' generated from that STR follows these rules:

- Contain only lower case alphabet, number and hyphen characters
  ([[:alnum:]-]).
- Not have *any* HTML tag like \"<code>..</code>\",
  \"<span class=..>..</span>\", etc.
- Not contain any URLs (if STR happens to be a Markdown link).
- Replace \".\" in STR with \"dot\", \"&\" with \"and\",
  \"+\" with \"plus\".
- Replace parentheses with double-hyphens.  So \"foo (bar) baz\"
  becomes \"foo--bar--baz\".
- Replace non [[:alnum:]-] chars with spaces, and then one or
  more consecutive spaces with a single hyphen.
- At most two consecutive hyphens are allowed.
- No hyphens allowed at the leading or trailing end of the slug.

\(fn STR)" nil nil)

(autoload 'org-hugo-export-as-md "ox-hugo" "\
Export current buffer to a Hugo-compatible Markdown buffer.

If narrowing is active in the current buffer, only export its
narrowed part.

If a region is active, export that region.

A non-nil optional argument ASYNC means the process should happen
asynchronously.  The resulting buffer should be accessible
through the `org-export-stack' interface.

When optional argument SUBTREEP is non-nil, export the sub-tree
at point, extracting information from the headline properties
first.

When optional argument VISIBLE-ONLY is non-nil, don't export
contents of hidden elements.

Export is done in a buffer named \"*Org Hugo Export*\", which
will be displayed when `org-export-show-temporary-export-buffer'
is non-nil.

Return the buffer the export happened to.

\(fn &optional ASYNC SUBTREEP VISIBLE-ONLY)" t nil)

(autoload 'org-hugo-export-to-md "ox-hugo" "\
Export current buffer to a Hugo-compatible Markdown file.

If narrowing is active in the current buffer, only export its
narrowed part.

If a region is active, export that region.

A non-nil optional argument ASYNC means the process should happen
asynchronously.  The resulting file should be accessible through
the `org-export-stack' interface.

When optional argument SUBTREEP is non-nil, export the sub-tree
at point, extracting information from the headline properties
first.

When optional argument VISIBLE-ONLY is non-nil, don't export
contents of hidden elements.

Return output file's name.

\(fn &optional ASYNC SUBTREEP VISIBLE-ONLY)" t nil)

(autoload 'org-hugo-export-wim-to-md "ox-hugo" "\
Export the current subtree/all subtrees/current file to a Hugo post.

This is an Export \"What I Mean\" function:

- If the current subtree has the \"EXPORT_FILE_NAME\" property, export
  that subtree.
- If the current subtree doesn't have that property, but one of its
  parent subtrees has, then export from that subtree's scope.
- If none of the subtrees have that property (or if there are no Org
  subtrees at all), call `org-hugo--export-file-to-md'.

- If ALL-SUBTREES is non-nil, export all valid Hugo post subtrees
  (that have the \"EXPORT_FILE_NAME\" property) in the current file
  to multiple Markdown posts.
- If ALL-SUBTREES is non-nil, and again if none of the subtrees have
  that property (or if there are no Org subtrees), call
  `org-hugo--export-file-to-md'.

A non-nil optional argument ASYNC means the process should happen
asynchronously.  The resulting file should be accessible through
the `org-export-stack' interface.

When optional argument VISIBLE-ONLY is non-nil, don't export
contents of hidden elements.

The optional argument NOERROR is passed to
`org-hugo--export-file-to-md'.

- If ALL-SUBTREES is non-nil:
  - If valid subtrees are found, return the list of output files.
  - If no valid subtrees are found, return value is the same as
    that of `org-hugo--export-file-to-md'.

- If ALL-SUBTREES is nil:
  - If `org-hugo--export-subtree-to-md' returns a non-nil value, return that.
  - Else return the value of `org-hugo--export-file-to-md'.

\(fn &optional ALL-SUBTREES ASYNC VISIBLE-ONLY NOERROR)" t nil)

(autoload 'org-hugo-debug-info "ox-hugo" "\
Get Emacs, Org and Hugo version and ox-hugo customization info.
The information is converted to Markdown format and copied to the
kill ring.  The same information is displayed in the Messages
buffer and returned as a string in Org format." t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ox-hugo" '("org-hugo-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ox-hugo-pandoc-cite" '("org-hugo-pandoc-cite-")))




)
(let ((load-file-name "/home/das/.emacs.d/elpa/org-static-blog-20210329.848/org-static-blog-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/org-static-blog-20210329.848/org-static-blog-autoloads.el") (car load-path))))



(autoload 'org-static-blog-publish "org-static-blog" "\
Render all blog posts, the index, archive, tags, and RSS feed.
Only blog posts that changed since the HTML was created are
re-rendered.

With a prefix argument, all blog posts are re-rendered
unconditionally.

\(fn &optional FORCE-RENDER)" t nil)

(autoload 'org-static-blog-publish-file "org-static-blog" "\
Publish a single POST-FILENAME.
The index, archive, tags, and RSS feed are not updated.

\(fn POST-FILENAME)" t nil)

(autoload 'org-static-blog-create-new-post "org-static-blog" "\
Creates a new blog post.
Prompts for a title and proposes a file name. The file name is
only a suggestion; You can choose any other file name if you so
choose.

\(fn &optional DRAFT)" t nil)

(autoload 'org-static-blog-create-new-draft "org-static-blog" "\
Creates a new blog draft.
Prompts for a title and proposes a file name. The file name is
only a suggestion; You can choose any other file name if you so
choose." t nil)

(autoload 'org-static-blog-mode "org-static-blog" "\
Blogging with org-mode and emacs.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "org-static-blog" '("concat-to-dir" "org-static-blog-")))


)
(let ((load-file-name "/home/das/.emacs.d/elpa/org-protocol-jekyll-20170328.1639/org-protocol-jekyll-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/org-protocol-jekyll-20170328.1639/org-protocol-jekyll-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "org-protocol-jekyll" '("org-protocol-jekyll")))


)
(let ((load-file-name "/home/das/.emacs.d/elpa/org-journal-20210326.1207/org-journal-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/org-journal-20210326.1207/org-journal-autoloads.el") (car load-path))))



(add-hook 'calendar-today-visible-hook 'org-journal-mark-entries)

(add-hook 'calendar-today-invisible-hook 'org-journal-mark-entries)

(autoload 'org-journal-mode "org-journal" "\
Mode for writing or viewing entries written in the journal.

\(fn)" t nil)

(define-obsolete-function-alias 'org-journal-open-next-entry 'org-journal-next-entry "2.1.0")

(define-obsolete-function-alias 'org-journal-open-previous-entry 'org-journal-previous-entry "2.1.0")

(autoload 'org-journal-convert-created-property-timestamps "org-journal" "\
Convert CREATED property timestamps to `org-journal-created-property-timestamp-format'.

\(fn OLD-FORMAT)" t nil)

(autoload 'org-journal-new-entry "org-journal" "\
Open today's journal file and start a new entry.

With a PREFIX arg, open the today's file, create a heading if it doesn't exist yet,
but do not create a new entry.

If given a TIME, create an entry for the time's day. If no TIME was given,
use the current time (which is interpreted as belonging to yesterday if
smaller than `org-extend-today-until`).

Whenever a journal entry is created the `org-journal-after-entry-create-hook'
hook is run.

\(fn PREFIX &optional TIME)" t nil)

(autoload 'org-journal-new-date-entry "org-journal" "\
Open the journal for the date indicated by point and start a new entry.

If the date is not today, it won't be given a time heading. With one prefix (C-u),
don't add a new heading.

If the date is in the future, create a schedule entry, unless two universal prefix
arguments (C-u C-u) are given. In that case insert just the heading.

\(fn PREFIX &optional EVENT)" t nil)

(autoload 'org-journal-new-scheduled-entry "org-journal" "\
Create a new entry in the future with an active timestamp.

With non-nil prefix argument create a regular entry instead of a TODO entry.

\(fn PREFIX &optional SCHEDULED-TIME)" t nil)

(autoload 'org-journal-reschedule-scheduled-entry "org-journal" "\
Reschedule an entry in the future.

\(fn &optional TIME)" t nil)

(autoload 'org-journal-open-current-journal-file "org-journal" "\
Open the current journal file" t nil)

(autoload 'org-journal-invalidate-cache "org-journal" "\
Clear `org-journal--dates' hash table, and the cache file." t nil)

(autoload 'org-journal-mark-entries "org-journal" "\
Mark days in the calendar for which a journal entry is present." t nil)

(autoload 'org-journal-read-entry "org-journal" "\
Open journal entry for selected date for viewing.

\(fn ARG &optional EVENT)" t nil)

(autoload 'org-journal-display-entry "org-journal" "\
Display journal entry for selected date in another window.

\(fn ARG &optional EVENT)" t nil)

(autoload 'org-journal-read-or-display-entry "org-journal" "\
Read an entry for the TIME and either select the new window when NOSELECT
is nil or avoid switching when NOSELECT is non-nil.

\(fn TIME &optional NOSELECT)" nil nil)

(autoload 'org-journal-next-entry "org-journal" "\
Go to the next journal entry." t nil)

(autoload 'org-journal-previous-entry "org-journal" "\
Go to the previous journal entry." t nil)

(autoload 'org-journal-search "org-journal" "\
Search for a string in the journal files.

See `org-read-date' for information on ways to specify dates.
If a prefix argument is given, search all dates.

\(fn STR &optional PERIOD-NAME)" t nil)

(autoload 'org-journal-search-calendar-week "org-journal" "\
Search for a string within a current calendar-mode week entries.

\(fn STR)" t nil)

(autoload 'org-journal-search-calendar-month "org-journal" "\
Search for a string within a current calendar-mode month entries.

\(fn STR)" t nil)

(autoload 'org-journal-search-calendar-year "org-journal" "\
Search for a string within a current calendar-mode year entries.

\(fn STR)" t nil)

(autoload 'org-journal-search-forever "org-journal" "\
Search for a string within all entries.

\(fn STR)" t nil)

(autoload 'org-journal-search-future "org-journal" "\
Search for a string within all future entries.

\(fn STR)" t nil)

(autoload 'org-journal-search-future-scheduled "org-journal" "\
Search for TODOs within all future entries." t nil)

(add-hook 'org-journal-mode-hook (lambda nil (add-hook org-journal-encrypt-on 'org-journal-encryption-hook nil t)))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "org-journal" '("org-journal-")))


)
(let ((load-file-name "/home/das/.emacs.d/elpa/dash-20210330.1544/dash-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/dash-20210330.1544/dash-autoloads.el") (car load-path))))



(autoload 'dash-fontify-mode "dash" "\
Toggle fontification of Dash special variables.

If called interactively, enable Dash-Fontify mode if ARG is
positive, and disable it if ARG is zero or negative.  If called
from Lisp, also enable the mode if ARG is omitted or nil, and
toggle it if ARG is `toggle'; disable the mode otherwise.

Dash-Fontify mode is a buffer-local minor mode intended for Emacs
Lisp buffers.  Enabling it causes the special variables bound in
anaphoric Dash macros to be fontified.  These anaphoras include
`it', `it-index', `acc', and `other'.  In older Emacs versions
which do not dynamically detect macros, Dash-Fontify mode
additionally fontifies Dash macro calls.

See also `dash-fontify-mode-lighter' and
`global-dash-fontify-mode'.

\(fn &optional ARG)" t nil)

(put 'global-dash-fontify-mode 'globalized-minor-mode t)

(defvar global-dash-fontify-mode nil "\
Non-nil if Global Dash-Fontify mode is enabled.
See the `global-dash-fontify-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-dash-fontify-mode'.")

(custom-autoload 'global-dash-fontify-mode "dash" nil)

(autoload 'global-dash-fontify-mode "dash" "\
Toggle Dash-Fontify mode in all buffers.
With prefix ARG, enable Global Dash-Fontify mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Dash-Fontify mode is enabled in all buffers where
`dash--turn-on-fontify-mode' would do it.
See `dash-fontify-mode' for more information on Dash-Fontify mode.

\(fn &optional ARG)" t nil)

(autoload 'dash-register-info-lookup "dash" "\
Register the Dash Info manual with `info-lookup-symbol'.
This allows Dash symbols to be looked up with \\[info-lookup-symbol]." t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "dash" '("!cdr" "!cons" "--" "->" "-a" "-butlast" "-c" "-d" "-e" "-f" "-gr" "-i" "-juxt" "-keep" "-l" "-m" "-no" "-o" "-p" "-r" "-s" "-t" "-u" "-value-to-list" "-when-let" "-zip" "dash-")))




)
(let ((load-file-name "/home/das/.emacs.d/elpa/kv-20140108.1534/kv-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/kv-20140108.1534/kv-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "kv" '("dotass" "keyword->symbol" "map-bind")))


)
(let ((load-file-name "/home/das/.emacs.d/elpa/esxml-20210323.1102/esxml-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/esxml-20210323.1102/esxml-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "esxml" '("attr" "esxml-" "pp-esxml-to-xml" "string-trim-whitespace" "sxml-to-" "xml-to-esxml")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "esxml-query" '("esxml-")))




)
(let ((load-file-name "/home/das/.emacs.d/elpa/nov-20210323.1105/nov-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/nov-20210323.1105/nov-autoloads.el") (car load-path))))



(autoload 'nov-mode "nov" "\
Major mode for reading EPUB documents

\(fn)" t nil)

(autoload 'nov-bookmark-jump-handler "nov" "\
The bookmark handler-function interface for bookmark BMK.

See also `nov-bookmark-make-record'.

\(fn BMK)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "nov" '("nov-")))


)
(let ((load-file-name "/home/das/.emacs.d/elpa/ht-20210119.741/ht-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/ht-20210119.741/ht-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ht" 'nil))


)
(let ((load-file-name "/home/das/.emacs.d/elpa/mu4e-views-20210228.1556/mu4e-views-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/mu4e-views-20210228.1556/mu4e-views-autoloads.el") (car load-path))))



(autoload 'mu4e-views-mu4e-use-view-msg-method "mu4e-views" "\
Apply METHOD for viewing emails in mu4e-headers view.

\(fn METHOD)" nil nil)

(autoload 'mu4e-views-mu4e-headers-windows-only "mu4e-views" "\
Show only the headers window of mu4e." t nil)

(autoload 'mu4e-views-cursor-msg-view-window-down "mu4e-views" "\
Scroll message view down if we are viewing the message using xwidget-webkit." t nil)

(autoload 'mu4e-views-cursor-msg-view-window-up "mu4e-views" "\
Scroll message view up if we are viewing the message using xwidget-webkit." t nil)

(autoload 'mu4e-views-mu4e-headers-next "mu4e-views" "\
Move to next message in headers view.

If a xwidget message view is open then use that to show the
message.  With prefix argument move N steps instead.

\(fn &optional N)" t nil)

(autoload 'mu4e-views-mu4e-headers-prev "mu4e-views" "\
Move to previous message in headers view.

If a xwidget message view is open then use that to show the
message.  With prefix argument move N steps backwards instead.

\(fn &optional N)" t nil)

(autoload 'mu4e-views-mu4e-headers-move "mu4e-views" "\
Move point LINES lines.
Forward (if LINES is positive) or backward (if LINES is negative).
If this succeeds, return the new docid.  Otherwise, return nil.

\(fn LINES)" nil nil)

(autoload 'mu4e-views-mu4e-headers-move-wrapper "mu4e-views" "\
Move by N steps in the headers view.

Negative numbers move backwards.  Record the window that we started from to
be able to respect `mu4e-views-next-previous-message-behaviour'.

\(fn N)" t nil)

(autoload 'mu4e-views-mu4e-extract-urls-from-msg "mu4e-views" "\
Prepare mu4e message data structure for MSG.
This data structure is used to support commands like browsing
urls in `mu4e-views' xwidget message view.

\(fn MSG)" t nil)

(autoload 'mu4e-views-mu4e-select-url-from-message "mu4e-views" "\
Select a url from a mu4e message." t nil)

(autoload 'mu4e-views-mu4e-open-attachment "mu4e-views" "\
Select an attached from a mu4e message and open it." t nil)

(autoload 'mu4e-views-mu4e-save-attachment "mu4e-views" "\
Select an attached from a mu4e message and save it." t nil)

(autoload 'mu4e-views-mu4e-save-all-attachments "mu4e-views" "\
Save all attachments to a single directory chosen by the user." t nil)

(autoload 'mu4e-views-mu4e-view-open-attachment "mu4e-views" "\
Wraps the `mu4e-view-open-attachment' function.

Passes on the message stored in `mu4e-views--current-mu4e-message'." t nil)

(autoload 'mu4e-views-mu4e-view-go-to-url "mu4e-views" "\
Wraps the `mu4e-view-go-to-url' function.

Passes on the message stored in `mu4e-views--current-mu4e-message'." t nil)

(autoload 'mu4e-views-mu4e-view-save-url "mu4e-views" "\
Wraps the `mu4e-view-save-url' function.

 Passes on the message stored in `mu4e-views--current-mu4e-message'." t nil)

(autoload 'mu4e-views-mu4e-view-save-attachment "mu4e-views" "\
Wraps the `mu4e-save-attachment' function.

 Passes on the message stored in `mu4e-views--current-mu4e-message'." t nil)

(autoload 'mu4e-views-mu4e-view-save-all-attachments "mu4e-views" "\
Wraps function to save all attachments using `mu4e-views--current-mu4e-message'." t nil)

(autoload 'mu4e-views-mu4e-view-action "mu4e-views" "\
Wraps the `mu4e-view-action' function.

Passes on the message stored in `mu4e-views--current-mu4e-message'." t nil)

(autoload 'mu4e-views-mu4e-view-fetch-url "mu4e-views" "\
Wraps the `mu4e-view-fetch-url' function.

Passes on the message stored in `mu4e-views--current-mu4e-message'." t nil)

(autoload 'mu4e-views-mu4e-select-view-msg-method "mu4e-views" "\
Select the method for viewing emails in `mu4e'." t nil)

(autoload 'mu4e-views-toggle-auto-view-selected-message "mu4e-views" "\
Toggle automatic viewing of message when moving around in the mu4e-headers view." t nil)

(autoload 'mu4e-views-unload-function "mu4e-views" "\
Uninstalls the advices on mu4e functions created by mu4e-views." t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "mu4e-views" '("mu4e-views-")))


)
(let ((load-file-name "/home/das/.emacs.d/elpa/modus-themes-20210418.327/modus-themes-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/modus-themes-20210418.327/modus-themes-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "modus-operandi-theme" '("modus-operandi")))



(autoload 'modus-themes-contrast "modus-themes" "\
Measure WCAG contrast ratio between C1 and C2.
C1 and C2 are color values written in hexadecimal RGB.

\(fn C1 C2)" nil nil)

(autoload 'modus-themes-color "modus-themes" "\
Return color value for COLOR from current palette.
COLOR is a key in `modus-themes-operandi-colors' or
`modus-themes-vivendi-colors'.

\(fn COLOR)" nil nil)

(autoload 'modus-themes-color-alts "modus-themes" "\
Return color value from current palette.
When Modus Operandi is enabled, return color value for color
LIGHT-COLOR.  When Modus Vivendi is enabled, return color value
for DARK-COLOR.  LIGHT-COLOR and DARK-COLOR are keys in
`modus-themes-operandi-colors' or `modus-themes-vivendi-colors'.

\(fn LIGHT-COLOR DARK-COLOR)" nil nil)

(autoload 'modus-themes-load-themes "modus-themes" "\
Ensure that the Modus themes are in `custom-enabled-themes'.

This function is intended for use in package declarations such as
those defined with the help of `use-package'.  The idea is to add
this function to the `:init' stage of the package's loading, so
that subsequent calls that assume the presence of a loaded theme,
like `modus-themes-toggle' or `modus-themes-load-operandi', will
continue to work as intended even if they are lazy-loaded (such
as when they are declared in the `:config' phase)." nil nil)

(autoload 'modus-themes-load-operandi "modus-themes" "\
Load `modus-operandi' and disable `modus-vivendi'.
Also run `modus-themes-after-load-theme-hook'." nil nil)

(autoload 'modus-themes-load-vivendi "modus-themes" "\
Load `modus-vivendi' and disable `modus-operandi'.
Also run `modus-themes-after-load-theme-hook'." nil nil)

(autoload 'modus-themes-toggle "modus-themes" "\
Toggle between `modus-operandi' and `modus-vivendi' themes.
Also runs `modus-themes-after-load-theme-hook' at its last stage
by virtue of calling either of `modus-themes-load-operandi' and
`modus-themes-load-vivendi' functions." t nil)

(when load-file-name (let ((dir (file-name-directory load-file-name))) (unless (equal dir (expand-file-name "themes/" data-directory)) (add-to-list 'custom-theme-load-path dir))))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "modus-themes" '("modus-themes-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "modus-vivendi-theme" '("modus-vivendi")))




)
(let ((load-file-name "/home/das/.emacs.d/elpa/modus-vivendi-theme-0.13.2/modus-vivendi-theme-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/modus-vivendi-theme-0.13.2/modus-vivendi-theme-autoloads.el") (car load-path))))


)
(let ((load-file-name "/home/das/.emacs.d/elpa/modus-operandi-theme-0.13.2/modus-operandi-theme-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/modus-operandi-theme-0.13.2/modus-operandi-theme-autoloads.el") (car load-path))))


)
(let ((load-file-name "/home/das/.emacs.d/elpa/markdown-mode-20210405.1349/markdown-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/markdown-mode-20210405.1349/markdown-mode-autoloads.el") (car load-path))))



(autoload 'markdown-mode "markdown-mode" "\
Major mode for editing Markdown files.

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("\\.\\(?:md\\|markdown\\|mkd\\|mdown\\|mkdn\\|mdwn\\)\\'" . markdown-mode))

(autoload 'gfm-mode "markdown-mode" "\
Major mode for editing GitHub Flavored Markdown files.

\(fn)" t nil)

(autoload 'markdown-view-mode "markdown-mode" "\
Major mode for viewing Markdown content.

\(fn)" t nil)

(autoload 'gfm-view-mode "markdown-mode" "\
Major mode for viewing GitHub Flavored Markdown content.

\(fn)" t nil)

(autoload 'markdown-live-preview-mode "markdown-mode" "\
Toggle native previewing on save for a specific markdown file.

If called interactively, enable Markdown-Live-Preview mode if ARG
is positive, and disable it if ARG is zero or negative.  If
called from Lisp, also enable the mode if ARG is omitted or nil,
and toggle it if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "markdown-mode" '("defun-markdown-" "gfm-" "markdown")))


)
(let ((load-file-name "/home/das/.emacs.d/elpa/i-ching-20210222.1519/i-ching-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/i-ching-20210222.1519/i-ching-autoloads.el") (car load-path))))



(autoload 'i-ching-describe-hexagram "i-ching" "\
Show the name of a HEXAGRAM (between POINT and MARK) based on it's unicode name.

\(fn POINT MARK)" t nil)

(autoload 'i-ching-cast "i-ching" "\
Cast a Hexagram using a particular METHOD.

There are various methods to divine a specific hexagram.
Depending on the context and circumstance some methods may be more suitable.

see: `i-ching-divination-method' & `i-ching-randomness-source' for details.

\(fn &optional METHOD)" t nil)

(autoload 'i-ching-insert-hexagram "i-ching" "\
Insert a hexagram either by casting or it's NUMBER in the King Wen sequence.

\(fn &optional NUMBER)" t nil)

(autoload 'i-ching-insert-hexagram-and-name "i-ching" "\
Insert a hexagram either by casting or it's NUMBER in the King Wen sequence.

\(fn &optional NUMBER)" t nil)

(autoload 'i-ching-hexagram-and-name-string "i-ching" "\
Return a hexagram either by casting or it's NUMBER in the King Wen sequence.

\(fn &optional NUMBER)" t nil)

(autoload 'i-ching-interpretation "i-ching" "\
Consult the I Ching to show an interpretation of a single HEXAGRAM.
The hexagram can be entered as a string, or by number.

\(fn HEXAGRAM)" t nil)

(autoload 'i-ching-query-string "i-ching" "\
Consult the I Ching using a particular METHOD.

\(fn &optional METHOD)" t nil)

(autoload 'i-ching-query "i-ching" "\
Consult the I Ching using a particular METHOD.

\(fn &optional METHOD)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "i-ching" '("i-ching-")))




)
(let ((load-file-name "/home/das/.emacs.d/elpa/elfeed-20210309.2323/elfeed-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/elfeed-20210309.2323/elfeed-autoloads.el") (car load-path))))



(autoload 'elfeed-update "elfeed" "\
Update all the feeds in `elfeed-feeds'." t nil)

(autoload 'elfeed "elfeed" "\
Enter elfeed." t nil)

(autoload 'elfeed-load-opml "elfeed" "\
Load feeds from an OPML file into `elfeed-feeds'.
When called interactively, the changes to `elfeed-feeds' are
saved to your customization file.

\(fn FILE)" t nil)

(autoload 'elfeed-export-opml "elfeed" "\
Export the current feed listing to OPML-formatted FILE.

\(fn FILE)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "elfeed" '("elfeed-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "elfeed-csv" '("elfeed-csv-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "elfeed-curl" '("elfeed-curl-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "elfeed-db" '("elfeed-" "with-elfeed-db-visit")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "elfeed-lib" '("elfeed-")))



(autoload 'elfeed-link-store-link "elfeed-link" "\
Store a link to an elfeed search or entry buffer.

When storing a link to an entry, automatically extract all the
entry metadata.  These can be used in the capture templates as
%:elfeed-entry-<prop>.  See `elfeed-entry--create' for the list
of available props." nil nil)

(autoload 'elfeed-link-open "elfeed-link" "\
Jump to an elfeed entry or search.

Depending on what FILTER-OR-ID looks like, we jump to either
search buffer or show a concrete entry.

\(fn FILTER-OR-ID)" nil nil)

(eval-after-load 'org `(funcall ',(lambda nil (if (version< (org-version) "9.0") (with-no-warnings (org-add-link-type "elfeed" #'elfeed-link-open) (add-hook 'org-store-link-functions #'elfeed-link-store-link)) (with-no-warnings (org-link-set-parameters "elfeed" :follow #'elfeed-link-open :store #'elfeed-link-store-link))))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "elfeed-log" '("elfeed-log")))



(autoload 'elfeed-search-bookmark-handler "elfeed-search" "\
Jump to an elfeed-search bookmarked location.

\(fn RECORD)" nil nil)

(autoload 'elfeed-search-desktop-restore "elfeed-search" "\
Restore the state of an elfeed-search buffer on desktop restore.

\(fn FILE-NAME BUFFER-NAME SEARCH-FILTER)" nil nil)

(add-to-list 'desktop-buffer-mode-handlers '(elfeed-search-mode . elfeed-search-desktop-restore))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "elfeed-search" '("elfeed-s")))



(autoload 'elfeed-show-bookmark-handler "elfeed-show" "\
Show the bookmarked entry saved in the `RECORD'.

\(fn RECORD)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "elfeed-show" '("elfeed-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "xml-query" '("xml-query")))




)
(let ((load-file-name "/home/das/.emacs.d/elpa/auto-compile-20201122.1157/auto-compile-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "/home/das/.emacs.d/elpa/auto-compile-20201122.1157/auto-compile-autoloads.el") (car load-path))))



(autoload 'auto-compile-mode "auto-compile" "\
Compile Emacs Lisp source files after the visiting buffers are saved.

If called interactively, enable Auto-Compile mode if ARG is
positive, and disable it if ARG is zero or negative.  If called
from Lisp, also enable the mode if ARG is omitted or nil, and
toggle it if ARG is `toggle'; disable the mode otherwise.

After a buffer containing Emacs Lisp code is saved to its source
file update the respective byte code file.  If the latter does
not exist do nothing.  Therefore to disable automatic compilation
remove the byte code file.  See command `toggle-auto-compile' for
a convenient way to do so.

This mode should be enabled globally, using it's globalized
variant `auto-compile-on-save-mode'.  Also see the related
`auto-compile-on-load-mode'.

\(fn &optional ARG)" t nil)

(put 'auto-compile-on-save-mode 'globalized-minor-mode t)

(defvar auto-compile-on-save-mode nil "\
Non-nil if Auto-Compile-On-Save mode is enabled.
See the `auto-compile-on-save-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `auto-compile-on-save-mode'.")

(custom-autoload 'auto-compile-on-save-mode "auto-compile" nil)

(autoload 'auto-compile-on-save-mode "auto-compile" "\
Toggle Auto-Compile mode in all buffers.
With prefix ARG, enable Auto-Compile-On-Save mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Auto-Compile mode is enabled in all buffers where
`turn-on-auto-compile-mode' would do it.
See `auto-compile-mode' for more information on Auto-Compile mode.

\(fn &optional ARG)" t nil)

(autoload 'toggle-auto-compile "auto-compile" "\
Toggle automatic compilation of an Emacs Lisp source file or files.

Read a file or directory name from the minibuffer defaulting to
the visited Emacs Lisp source file or `default-directory' if no
such file is being visited in the current buffer.

If the user selects a file then automatic compilation of only
that file is toggled.  Since both `auto-compile-on-save' and
`auto-compile-on-save' only ever _recompile_ byte code files,
toggling automatic compilation is done simply by creating or
removing the respective byte code file.

If the user selects a directory then automatic compilation for
multiple files is toggled as follows:

* With a positive prefix argument always compile source files;
  with a negative prefix argument always remove byte code files.

* Otherwise the existence or absence of the byte code file of
  the source file that was current when this command was invoked
  determines whether byte code files should be created or removed.

* If no Emacs Lisp source file is being visited in the buffer
  that was current when the command was invoked ask the user what
  to do.

* When _removing_ byte code files then all byte code files are
  removed.  If `auto-compile-deletes-stray-dest' is non-nil this
  even includes byte code files for which no source file exists.

* When _creating_ byte code files only do so for source files
  that are actual libraries.  Source files that provide the
  correct feature are considered to be libraries; see
  `packed-library-p'.

* Note that non-libraries can still be automatically compiled,
  you just cannot _recursively_ turn on automatic compilation
  using this command.

* When `auto-compile-toggle-recompiles' is non-nil recompile all
  affected source files even when the respective source files are
  up-to-date.  Do so even for non-library source files.

* Only enter subdirectories for which `packed-ignore-directory-p'
  returns nil; i.e. don't enter hidden directories or directories
  containing a file named \".nosearch\".

\(fn FILE ACTION)" t nil)

(defvar auto-compile-on-load-mode nil "\
Non-nil if Auto-Compile-On-Load mode is enabled.
See the `auto-compile-on-load-mode' command
for a description of this minor mode.")

(custom-autoload 'auto-compile-on-load-mode "auto-compile" nil)

(autoload 'auto-compile-on-load-mode "auto-compile" "\
Before loading a library recompile it if it needs recompilation.

If called interactively, enable Auto-Compile-On-Load mode if ARG
is positive, and disable it if ARG is zero or negative.  If
called from Lisp, also enable the mode if ARG is omitted or nil,
and toggle it if ARG is `toggle'; disable the mode otherwise.

A library needs to be recompiled if the source file is newer than
it's byte-compile destination.  Without this advice the outdated
byte code file would be loaded instead.

Also see the related `auto-compile-on-save-mode'.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "auto-compile" '("auto-compile-" "byte-compile-log-warning" "load" "mode-line-" "require" "save-buffers-kill-" "turn-on-auto-compile-mode")))


)
(setq package-activated-list
      (append
       '(xwidgets-reuse whole-line-or-region bind-key use-package macrostep slime shrink-whitespace request recently packed org ox-hugo org-static-blog org-protocol-jekyll org-journal dash kv esxml nov ht mu4e-views modus-themes modus-vivendi-theme modus-operandi-theme markdown-mode i-ching elfeed auto-compile)
       package-activated-list))
(progn
  (require 'info)
  (info-initialize)
  (setq Info-directory-list
	(append
	 '("/home/das/.emacs.d/elpa/i-ching-20210222.1519" "/home/das/.emacs.d/elpa/modus-themes-20210418.327" "/home/das/.emacs.d/elpa/dash-20210330.1544" "/home/das/.emacs.d/elpa/org-20201216" "/home/das/.emacs.d/elpa/slime-20210417.1210" "/home/das/.emacs.d/elpa/use-package-20210207.1926")
	 Info-directory-list)))

;; Local Variables:
;; version-control: never
;; no-byte-compile: t
;; no-update-autoloads: t
;; End:
